// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createParsedFilename = `-- name: CreateParsedFilename :exec
INSERT INTO parsed_filenames (
    processing_result_id, parser_name, original_filename, title, issue_number, year,
    publisher, volume_number, confidence, notes
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
) ON CONFLICT(original_filename, parser_name) DO UPDATE SET
    processing_result_id = excluded.processing_result_id,
    title = excluded.title,
    issue_number = excluded.issue_number,
    year = excluded.year,
    publisher = excluded.publisher,
    volume_number = excluded.volume_number,
    confidence = excluded.confidence,
    notes = excluded.notes
`

type CreateParsedFilenameParams struct {
	ProcessingResultID sql.NullInt64
	ParserName         string
	OriginalFilename   string
	Title              string
	IssueNumber        string
	Year               sql.NullString
	Publisher          sql.NullString
	VolumeNumber       sql.NullString
	Confidence         string
	Notes              sql.NullString
}

func (q *Queries) CreateParsedFilename(ctx context.Context, arg CreateParsedFilenameParams) error {
	_, err := q.db.ExecContext(ctx, createParsedFilename,
		arg.ProcessingResultID,
		arg.ParserName,
		arg.OriginalFilename,
		arg.Title,
		arg.IssueNumber,
		arg.Year,
		arg.Publisher,
		arg.VolumeNumber,
		arg.Confidence,
		arg.Notes,
	)
	return err
}

const deleteParsedFilenamesByResultID = `-- name: DeleteParsedFilenamesByResultID :exec
DELETE FROM parsed_filenames WHERE processing_result_id = ?
`

func (q *Queries) DeleteParsedFilenamesByResultID(ctx context.Context, processingResultID int64) error {
	_, err := q.db.ExecContext(ctx, deleteParsedFilenamesByResultID, processingResultID)
	return err
}

const getProcessingResult = `-- name: GetProcessingResult :one
SELECT id, filename, success, error, processed_at, processing_time_ms, match_confidence, reasoning, comicvine_id, comicvine_url FROM processing_results WHERE filename = ?
`

func (q *Queries) GetProcessingResult(ctx context.Context, filename string) (ProcessingResult, error) {
	row := q.db.QueryRowContext(ctx, getProcessingResult, filename)
	var i ProcessingResult
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.Success,
		&i.Error,
		&i.ProcessedAt,
		&i.ProcessingTimeMs,
		&i.MatchConfidence,
		&i.Reasoning,
		&i.ComicvineID,
		&i.ComicvineUrl,
	)
	return i, err
}

const upsertIssue = `-- name: UpsertIssue :exec
INSERT INTO comic_vine_issues (
    id, volume_id, name, issue_number, cover_date, store_date, description,
    site_detail_url, image_small_url, image_medium_url, image_large_url
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
) ON CONFLICT(id) DO UPDATE SET
    volume_id = excluded.volume_id,
    name = excluded.name,
    issue_number = excluded.issue_number,
    cover_date = excluded.cover_date,
    store_date = excluded.store_date,
    description = excluded.description,
    site_detail_url = excluded.site_detail_url,
    image_small_url = excluded.image_small_url,
    image_medium_url = excluded.image_medium_url,
    image_large_url = excluded.image_large_url
`

type UpsertIssueParams struct {
	ID             int64
	VolumeID       int64
	Name           sql.NullString
	IssueNumber    sql.NullString
	CoverDate      sql.NullString
	StoreDate      sql.NullString
	Description    sql.NullString
	SiteDetailUrl  sql.NullString
	ImageSmallUrl  sql.NullString
	ImageMediumUrl sql.NullString
	ImageLargeUrl  sql.NullString
}

func (q *Queries) UpsertIssue(ctx context.Context, arg UpsertIssueParams) error {
	_, err := q.db.ExecContext(ctx, upsertIssue,
		arg.ID,
		arg.VolumeID,
		arg.Name,
		arg.IssueNumber,
		arg.CoverDate,
		arg.StoreDate,
		arg.Description,
		arg.SiteDetailUrl,
		arg.ImageSmallUrl,
		arg.ImageMediumUrl,
		arg.ImageLargeUrl,
	)
	return err
}

const upsertProcessingResult = `-- name: UpsertProcessingResult :one
INSERT INTO processing_results (
    filename, success, error, processed_at, processing_time_ms,
    match_confidence, reasoning, comicvine_id, comicvine_url
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?
) ON CONFLICT(filename) DO UPDATE SET
    success = excluded.success,
    error = excluded.error,
    processed_at = excluded.processed_at,
    processing_time_ms = excluded.processing_time_ms,
    match_confidence = excluded.match_confidence,
    reasoning = excluded.reasoning,
    comicvine_id = excluded.comicvine_id,
    comicvine_url = excluded.comicvine_url
RETURNING id
`

type UpsertProcessingResultParams struct {
	Filename         string
	Success          bool
	Error            sql.NullString
	ProcessedAt      time.Time
	ProcessingTimeMs int64
	MatchConfidence  sql.NullString
	Reasoning        sql.NullString
	ComicvineID      sql.NullInt64
	ComicvineUrl     sql.NullString
}

func (q *Queries) UpsertProcessingResult(ctx context.Context, arg UpsertProcessingResultParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, upsertProcessingResult,
		arg.Filename,
		arg.Success,
		arg.Error,
		arg.ProcessedAt,
		arg.ProcessingTimeMs,
		arg.MatchConfidence,
		arg.Reasoning,
		arg.ComicvineID,
		arg.ComicvineUrl,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const upsertVolume = `-- name: UpsertVolume :exec
INSERT INTO comic_vine_volumes (
    id, name, start_year, publisher_name, site_detail_url
) VALUES (
    ?, ?, ?, ?, ?
) ON CONFLICT(id) DO UPDATE SET
    name = excluded.name,
    start_year = excluded.start_year,
    publisher_name = excluded.publisher_name,
    site_detail_url = excluded.site_detail_url
`

type UpsertVolumeParams struct {
	ID            int64
	Name          string
	StartYear     sql.NullString
	PublisherName sql.NullString
	SiteDetailUrl sql.NullString
}

func (q *Queries) UpsertVolume(ctx context.Context, arg UpsertVolumeParams) error {
	_, err := q.db.ExecContext(ctx, upsertVolume,
		arg.ID,
		arg.Name,
		arg.StartYear,
		arg.PublisherName,
		arg.SiteDetailUrl,
	)
	return err
}

const listParsedFilenames = `-- name: ListParsedFilenames :many
SELECT id, processing_result_id, parser_name, original_filename, title, issue_number, year, publisher, volume_number, confidence, notes FROM parsed_filenames ORDER BY id DESC
`

func (q *Queries) ListParsedFilenames(ctx context.Context) ([]ParsedFilename, error) {
	rows, err := q.db.QueryContext(ctx, listParsedFilenames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ParsedFilename
	for rows.Next() {
		var i ParsedFilename
		if err := rows.Scan(
			&i.ID,
			&i.ProcessingResultID,
			&i.ParserName,
			&i.OriginalFilename,
			&i.Title,
			&i.IssueNumber,
			&i.Year,
			&i.Publisher,
			&i.VolumeNumber,
			&i.Confidence,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
